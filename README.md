Application2
Engineering Analysis - Discussion Questions

Task Timing and Jitter: 
When looking at the console as well as the blinking LED, you can see that they are both functioning in their design period of 1 second. I double checked this by using a debugging print statement (similar to the one that was used in Application 1). The only drift that I observed was the initial delay before the first cycle happened which was about 10ms. After that the blinking and the printing were both consistent in their timing. vTaskDelayUntil is more consistent than vTaskDelay because it calculates the next wake time based on the period of ticks from the last wake time (next wake = last wake + period ticks). This causes the task to begin every time on the period that it is designed to. This differs from vTaskDelay because vTaskDelay has a set time like 500ms or whatever is entered by design and will always wait until that period (500ms or ...) is done. Unlike vTaskDelayUntil, vTaskDelay will always have that delay FROM when it is called regardless of whether the task was called later than expected due to software design delays or other variables present in a RTOS. This can lead to tasks falling out of sync (starting too late) or missing deadlines.

Priority-Based Preemption: 
Because the sensor task is a higher priority than the print task, in the event that the print task was trying to print at the same time that the sensor task was in the ready state, the sensor task would interrupt the print task immediately without waiting. Based on my understanding of FreeRTOS and what I had observed in my own application, I would conclude that the sensor task (which has a higher priority) is chosen to run before the others. I saw this in my own simulation by incorporating a print statement that tracks the time the print task and LED task are ran. Initially, there is a 10ms delay and I believe that this was caused by the sensor task completing. This would explain why it does not affect the other two tasks later on in the simulation because the scheduler essentially gave itself a buffer between the sensor task and the other two.

Effect of Task Execution Time: 
If the sensor task had a longer time to complete, like 300 ms, this could cause issues for the print task and LED task by not allowing enough time for those task to complete without being interrupted. The sensor task having a time period of 300ms would only leave 200ms before the next task call by the scheduler for the other task. In this simulation, the other two tasks are not very time heavy for completion, so it most likely would not affect them. However, if they were longer in time to complete it would most likely affect them and cause interruptions by the sensor task. If the task runs longer than the period allows, when using vTaskDelayUntil, the scheduler will see that the current time is greater than the period and schedule the next call as soon as the previous call is complete, then immediately run the next iteration of the task instead of delaying the task because it is already late. This would lead to symptoms such as missed readings, delayed toggles, etc. due to the task now being put "out of time". The delay caused by the scheduler to ensure the previous iteration is complete causes the RTOS to lose sync with the real time (it still would maintain its period unless it again takes longer than the period to complete the task). When it comes to real-time scheduling concepts, I would say this issue most relates to the Weakness in single threads, where high CPU utilization on a single core can lead to starvation of lower priority tasks causing misses in deadlines. It would also lead to issues when dealing with both hard and soft real time system requirements. Hard systems would catastrophically fail and soft systems would slowly deteriorate in functionality over time. To counter this you could put the higher priority task on a separate core from the lower priority task in order to avoid them being starved from a higher priority task missing deadlines caused by an overloaded core. 

vTaskDelay vs vTaskDelayUntil: 
We use vTaskDelayUntil vs vTaskDelay because with something as sensitive as an LDR module we need to have accurate reading at consistent times in order to obtain a true average of the light being read in the LDR. We do not want the iterations to be affected by readings taking longer than other and leading to jitter with vTaskDelay. This would lead us to issues with potentially missing critical readings from the sensor that could potentially change the average drastically. As discussed in question 2, vTaskDelay differs from vTaskDelayUntil because vTaskDelay will always schedule the next call x amount of time from when the function was called - regardless of how long the time to complete was for the task. vTaskDelayUntil on the other hand will calculate the next call from the last call + the period in ticks (next call = last call + period ticks), allowing the sensor task to be called in the correct period regardless of how long the previous iteration took to complete (as long as its not longer than the period). Small errors would accumulate from the use of vTaskDelay in the sensor task because the sensors time to complete could be slightly different each time causing the true period to very slightly change from iteration to iteration and cause the task scheduling to be out of sync with other tasks or timing schedules. This differs from the LED task because we are not gathering true data from the blinking LED. In my case, the LED serves only to indicate when the module is actively scanning (idea for theme). A slight timing drift in the LED task would not lead to missed or inaccurate data like it potentially could for the sensor task.

Themeatic Integration Reflection: 
My thematic integration was a space system. Here is how I connected the three different tasks to fit the theme:
LED Task -> I used two different LEDs (one red, one green) in order to show when a radar system was actively scanning the surrounding area. The red LED would turn on when the scanning is active and the green LED would turn on when the scanner was not actively scanning.
Print Task -> I used the print task as a counter that should the time before the Scanner would activate, as well as showing the scanner actively scanning by printing "scanning..." in 1s intervals, as well as "Scan complete" when it was done scanning. My print function also simultaneously printed the current lux value with each countdown message and the Ambient Lighting Average (ALA) when the scan was complete. This obviously would be used for transmitting data as well as updating countdowns to the main console for a spacecraft.
Sensor Task -> I made the sensor task act ask if it was "scanning" or reading the surrounding area of a spacecraft for ambient lighting. This could be used for detecting direction for a spacecraft as well as sensing approaching planets, moons, or stars that would reflect light.

Bonus: 
I designed an experiment in which I removed the vTaskDelayUntil function from the sensor task to cause it to completely flood the core, not allocating any time for the other two tasks to function, especially with them being a lower priority task than the sensor task. The changes were made in the sensor task. When I did this the countdown from the print task did not print and the LED did not blink for even one iteration. The only thing that printed was the ** ALERT ** print statement inside of the sensor task.

Citations of AI:
For this assignment I did not use AI for very much besides checking my final work. I used it to look for grammatical errors on this part of the assignment (Engineering analysis) as well making sure that what I was saying, and how I understood it was correct. I did not use it in the coding, and the responses that I gave came from my understanding of the material as well as references to past assignments - Specifically Application 1 and Homework 4, as well as experimentation with the simulation.
